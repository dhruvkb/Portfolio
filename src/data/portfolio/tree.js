const nodeType = {
  FOLDER: 'folder',
  FILE: 'file'
}

/**
 * A class that implements one node in a file-system tree. Each node may either
 * be a file or a folder and may have children if it is a folder.
 */
class Node {
  /**
   * Create a new object of class Node.
   *
   * @constructor
   * @constructs {Node}
   *
   * @param {string} type - the type of Node this is in the filesystem
   * @param {string} icon - the icon associated with the Node
   * @param {string} name - the name of the Node
   * @param {Array} aliases - the list of alternative names of the Node
   */
  constructor (type, icon, name, aliases = []) {
    this.type = type

    this.icon = icon
    this.name = name
    this.aliases = aliases

    this.parent = null
    this.children = []
  }

  /**
   * Check if a current Node matches the given name.
   *
   * @param {string} name - the name which is to be checked for a match
   * @returns {boolean} whether the given name is one of the Node's valid names
   */
  hasName (name) {
    return this.name === name || this.aliases.includes(name.toLocaleLowerCase())
  }
}

/**
 * A class that implements the tree data type for Node objects.
 */
class Tree {
  /**
   * Create a new object of class Tree.
   *
   * @constructor
   * @constructs {Tree}
   *
   * @param {Node} root - the root Node of the tree
   */
  constructor (root) {
    root.parent = root // Allows `cd ..` any number of times
    this.root = root
  }

  /**
   * Traverse the tree using the DFT algorithm.
   * @param {function} callbackFn - the function to execute on each node
   */
  traverseDepthFirst (callbackFn) {
    (function recurse (currentNode) {
      currentNode.children.forEach(child => {
        recurse(child)
      })
      callbackFn(currentNode)
    })(this.root)
  }

  /**
   * Traverse the tree with the given function and perform the given action
   * on all Nodes encountered during the traversal.
   * @param {function} callbackFn - the action to perform on the traversed Nodes
   * @param {function} traversalFn - the traversal function to employ
   */
  traverse (traversalFn, callbackFn) {
    traversalFn.apply(this, [callbackFn]) // Call traversal, with this as context
  }

  /**
   * Add the given Node to the tree under the Node with the specified name.
   * @param {Node} node - the Node to add to the tree
   * @param {string} parentName - the name of the Node above this one
   * @param {function} traversalFn - the traversal function to employ
   */
  add (node, parentName, traversalFn) {
    let parent = null

    this.traverse(traversalFn, (node) => {
      if (node.name === parentName) {
        parent = node
      }
    })

    if (parent) {
      parent.children.push(node)
      node.parent = parent
    } else {
      console.log(`Error occurred when adding ${node.name} to ${parentName}`)
    }
  }
}

/**
 * Create an object of class Tree using the JSON tree object.
 * @param {Object} basicTree - the JSON object to convert to a tree
 * @returns {Tree} the Tree object generated by traversing basicTree
 */
function generateTree (basicTree) {
  const node = new Node(
    basicTree.type,
    basicTree.icon,
    basicTree.name,
    basicTree.aliases
  )
  const tree = new Tree(node)

  populateTree(tree, basicTree)

  return tree
}

/**
 * Populate the object of class Tree by recursively traversing the JSON tree.
 * @param {Tree} tree - the Tree object being populated
 * @param {Object} basicNode - the current JSON node to traverse
 */
function populateTree (tree, basicNode) {
  const basicChildren = basicNode.children

  for (let i = 0; i < basicChildren.length; i++) {
    const basicChild = basicChildren[i]
    const childNode = new Node(
      basicChild.type,
      basicChild.icon,
      basicChild.name,
      basicChild.aliases
    )

    tree.add(childNode, basicNode.name, tree.traverseDepthFirst)

    if (basicChild.type === nodeType.FOLDER) {
      populateTree(tree, basicChild)
    }
  }
}

export {
  nodeType,
  generateTree
}
